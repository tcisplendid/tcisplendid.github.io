---
title: 学习算法
tags:
---

学习算法的初衷主要是因为面试，但是比起刷更多的难题，我希望能梳理基础和经典的算法之余，也探索解决算法问题的思维过程。

## 从问题与解开始
我们遇见的算法问题，通常可以分成三个部分：
1. 穷举/遍历问题：这是计算机主要增强人类能力的地方，所以大部分算法归根到底都有无法避开的穷举/遍历的环节，遍历输入，或者穷举输出（解空间）。
2. 数学问题：用“数学”是指分析问题特性、进行演绎推理、发现一些必然的结论，而这必然的结论会使问题归约为一个相对或者非常简单的问题。譬如说对等差数列求和，当然可以遍历，但是归约为一个公式能极大简化计算（O(n)到O(1))。
3. 设计问题：有时候解决方案必须考虑问题描述之外的一些因素，包括输入异常、计算资源、兼容性、代码的可读性、问题可能的变化等等。

我们的心智努力可能主要集中在数学问题和设计问题上，但是有必要强调穷举/遍历部分的重要性。因为穷举和遍历只有一个工作环节：定义问题和解空间。而有时换了一个定义，问题就相当于被解决了。譬如说一些最大化最小值问题（譬如lc 1552），直接的思路往往是从原问题的输入入手，但是如果把问题转换为在原问题的解空间查找一个符合要求的值，问题就会变得容易许多。

## （暴力）搜索
正如我们所说，一个算法问题很难避开穷举/遍历的环节，而搜索是纯粹依靠穷举的算法，所以它就能成为很多算法的组成部分，我们不得不优先考虑。

### 二分搜索
二分法的重要性体现在两个方面：
* 它解决的是在一组元素中找到符合要求的某个元素这类问题。这个问题太过基础和普遍，所以它的解法很重要。（二分法需要数组有序，排序也是另一个太过基础和普遍的问题）
* 它采用的分治思想也太过有用。

但是这么基础的二分法，要想轻松写出bug-free的代码也是困难的（参考维基对二分法的历史介绍）。尤其是在需要写二分法的一些变体时，譬如有重复元素时是返回最左侧或是最右侧的index。
针对这些变体有几个注意点：
1. 循环要能够（在只有两个元素的情况下）结束。譬如说以下代码想要实现查找最右侧元素（如果元素有重复查找index最大的那个）：
```
lo, hi = 0, n-1
while lo < hi:
    mid = (lo+hi) // 2
    if arr[mid] <= target:
        lo = mid
    else:
        hi = mid-1
```
可以发现如果在\[0,1\]里查0，lo,hi,mid会分别始终等于0,1,0，无限循环。
导致问题的原因是在if的两个分支中，hi确定会减少，但是lo却可能不变。因此解决方案是让`mid=(lo+hi+1) // 2`，这样if的两个分支在每次循环都一定会缩小区间的范围。
2. lo和hi选择开区间还是闭区间对于mid的运算有影响，因此对循环的结束和分支的写法有影响。而根据[Dijkstra的建议](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html)，左闭右开区间是更好的选择。至少它能减少一个检查（譬如查找>=target的最小元素，当返回n-1时必须要检查这个元素是不是满足条件的最小元素——当然也可以在一开始检查，`if arr[n-1]<target: return n`，但这个检查是免不了的），不过这也就需要在函数的规格中确定当不存在所求元素时返回n而不是-1。
3. `mid=(lo+hi+1) // 2`这种写法在用整型的语言中是错误的（Java近些年被发现的错误，这可能导致溢出），但是在Python中是可以的，因为Python中整数没有精度限制。

除了上文这种记录区间左端点和右端点的写法，二分法还有一种等价的写法，通过记录区间的左端点和区间长度来计算中点。C++ STL里的lower_bound()和upper_bound()即是使用后一种。

### 路径搜索
